//! User configuration schema and YAML generation.
//!
//! This module handles the user-specific configuration generated by the setup wizard.
//! The config is stored as YAML and contains encrypted secrets.

use anyhow::{Context, Result};
use secrecy::{ExposeSecret, SecretString};
use serde::{Deserialize, Serialize};
use std::path::Path;

use crate::Encryptor;

/// User configuration generated by the setup wizard.
///
/// This is serialized to YAML and stored in the user's config directory.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct UserConfig {
    /// Config file version for migrations
    pub version: String,
    /// User profile settings
    pub profile: UserProfile,
    /// Integration configurations
    pub integrations: IntegrationsConfig,
    /// Splunk configuration (manual, optional)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub splunk: Option<SplunkConfig>,
}

/// User profile configuration.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct UserProfile {
    /// User's display name
    pub display_name: String,
    /// Jira email/username for ticket filtering
    pub jira_email: String,
    /// Ticket states to track (e.g., "Ready for QA", "In Progress")
    pub ticket_states: Vec<String>,
}

/// Integration configurations container.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct IntegrationsConfig {
    /// Jira integration (required)
    pub jira: JiraConfig,
    /// Postman integration (optional)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub postman: Option<PostmanConfig>,
    /// Testmo integration (optional)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub testmo: Option<TestmoConfig>,
}

/// Jira authentication type stored in config.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum JiraAuthType {
    /// API Token authentication
    ApiToken,
    /// OAuth 2.0 authentication
    OAuth,
}

/// Jira integration configuration with encrypted credentials.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct JiraConfig {
    /// Jira instance URL (e.g., `https://company.atlassian.net`)
    pub instance_url: String,
    /// Authentication type
    pub auth_type: JiraAuthType,
    /// Email for API Token auth (encrypted)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub email_encrypted: Option<String>,
    /// API Token (encrypted) - for API Token auth
    #[serde(skip_serializing_if = "Option::is_none")]
    pub api_token_encrypted: Option<String>,
    /// OAuth Client ID (encrypted) - for OAuth auth
    #[serde(skip_serializing_if = "Option::is_none")]
    pub client_id_encrypted: Option<String>,
    /// OAuth Client Secret (encrypted) - for OAuth auth
    #[serde(skip_serializing_if = "Option::is_none")]
    pub client_secret_encrypted: Option<String>,
}

/// Postman integration configuration with encrypted API key.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct PostmanConfig {
    /// Encrypted API Key
    pub api_key_encrypted: String,
    /// Optional workspace ID filter
    #[serde(skip_serializing_if = "Option::is_none")]
    pub workspace_id: Option<String>,
}

/// Testmo integration configuration with encrypted API key.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct TestmoConfig {
    /// Testmo instance URL
    pub instance_url: String,
    /// Encrypted API Key
    pub api_key_encrypted: String,
}

/// Splunk configuration (manual, no authentication in v1).
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct SplunkConfig {
    /// Splunk base URL
    pub base_url: String,
    /// Default index to search
    #[serde(skip_serializing_if = "Option::is_none")]
    pub default_index: Option<String>,
}

// ============================================================================
// Builder for creating UserConfig from setup wizard data
// ============================================================================

/// Input data from the setup wizard (plaintext secrets).
#[derive(Debug, Clone)]
pub struct SetupWizardInput {
    pub profile: ProfileInput,
    pub jira: JiraInput,
    pub postman: Option<PostmanInput>,
    pub testmo: Option<TestmoInput>,
    pub splunk: Option<SplunkInput>,
}

#[derive(Debug, Clone)]
pub struct ProfileInput {
    pub display_name: String,
    pub jira_email: String,
    pub ticket_states: Vec<String>,
}

/// Jira authentication method for user config.
#[derive(Debug, Clone)]
pub enum JiraAuthInput {
    /// API Token authentication (recommended)
    ApiToken {
        email: String,
        api_token: SecretString,
    },
    /// OAuth 2.0 authentication
    OAuth {
        client_id: String,
        client_secret: SecretString,
    },
}

#[derive(Debug, Clone)]
pub struct JiraInput {
    pub instance_url: String,
    pub auth: JiraAuthInput,
}

#[derive(Debug, Clone)]
pub struct PostmanInput {
    pub api_key: SecretString,
    pub workspace_id: Option<String>,
}

#[derive(Debug, Clone)]
pub struct TestmoInput {
    pub instance_url: String,
    pub api_key: SecretString,
}

#[derive(Debug, Clone)]
pub struct SplunkInput {
    pub base_url: String,
    pub default_index: Option<String>,
}

impl UserConfig {
    /// Current config file version.
    pub const VERSION: &'static str = "1.0";

    /// Create a new user config from setup wizard input.
    ///
    /// Encrypts all secrets using the provided encryptor.
    ///
    /// # Errors
    ///
    /// Returns an error if encryption of any secret fails.
    pub fn from_wizard_input(input: SetupWizardInput, encryptor: &Encryptor) -> Result<Self> {
        // Encrypt Jira credentials based on auth type
        let jira = match input.jira.auth {
            JiraAuthInput::ApiToken { email, api_token } => JiraConfig {
                instance_url: input.jira.instance_url,
                auth_type: JiraAuthType::ApiToken,
                email_encrypted: Some(
                    encryptor
                        .encrypt(&email)
                        .context("Failed to encrypt Jira email")?,
                ),
                api_token_encrypted: Some(
                    encryptor
                        .encrypt(api_token.expose_secret())
                        .context("Failed to encrypt Jira API token")?,
                ),
                client_id_encrypted: None,
                client_secret_encrypted: None,
            },
            JiraAuthInput::OAuth {
                client_id,
                client_secret,
            } => JiraConfig {
                instance_url: input.jira.instance_url,
                auth_type: JiraAuthType::OAuth,
                email_encrypted: None,
                api_token_encrypted: None,
                client_id_encrypted: Some(
                    encryptor
                        .encrypt(&client_id)
                        .context("Failed to encrypt Jira client ID")?,
                ),
                client_secret_encrypted: Some(
                    encryptor
                        .encrypt(client_secret.expose_secret())
                        .context("Failed to encrypt Jira client secret")?,
                ),
            },
        };

        // Encrypt optional integrations
        let postman = input
            .postman
            .map(|p| -> Result<PostmanConfig> {
                Ok(PostmanConfig {
                    api_key_encrypted: encryptor
                        .encrypt(p.api_key.expose_secret())
                        .context("Failed to encrypt Postman API key")?,
                    workspace_id: p.workspace_id,
                })
            })
            .transpose()?;

        let testmo = input
            .testmo
            .map(|t| -> Result<TestmoConfig> {
                Ok(TestmoConfig {
                    instance_url: t.instance_url,
                    api_key_encrypted: encryptor
                        .encrypt(t.api_key.expose_secret())
                        .context("Failed to encrypt Testmo API key")?,
                })
            })
            .transpose()?;

        let splunk = input.splunk.map(|s| SplunkConfig {
            base_url: s.base_url,
            default_index: s.default_index,
        });

        Ok(Self {
            version: Self::VERSION.to_string(),
            profile: UserProfile {
                display_name: input.profile.display_name,
                jira_email: input.profile.jira_email,
                ticket_states: input.profile.ticket_states,
            },
            integrations: IntegrationsConfig {
                jira,
                postman,
                testmo,
            },
            splunk,
        })
    }

    /// Serialize to YAML string.
    ///
    /// # Errors
    ///
    /// Returns an error if YAML serialization fails.
    pub fn to_yaml(&self) -> Result<String> {
        serde_yaml::to_string(self).context("Failed to serialize config to YAML")
    }

    /// Write config to a YAML file.
    ///
    /// # Errors
    ///
    /// Returns an error if file creation or writing fails.
    pub fn write_to_file(&self, path: &Path) -> Result<()> {
        let yaml = self.to_yaml()?;

        // Create parent directories if needed
        if let Some(parent) = path.parent() {
            std::fs::create_dir_all(parent).context("Failed to create config directory")?;
        }

        std::fs::write(path, yaml).context("Failed to write config file")?;
        Ok(())
    }

    /// Load config from a YAML file.
    ///
    /// # Errors
    ///
    /// Returns an error if the file cannot be read or parsed.
    pub fn from_file(path: &Path) -> Result<Self> {
        let contents = std::fs::read_to_string(path).context("Failed to read config file")?;
        serde_yaml::from_str(&contents).context("Failed to parse config YAML")
    }

    /// Get the default config file path.
    ///
    /// # Errors
    ///
    /// Returns an error if the config directory cannot be determined.
    pub fn default_path() -> Result<std::path::PathBuf> {
        let config_dir = dirs::config_dir().context("Could not determine config directory")?;
        Ok(config_dir.join("qa-intelligent-pms").join("config.yaml"))
    }
}

// ============================================================================
// Validation
// ============================================================================

/// Validation error with details for fixing.
#[derive(Debug, Clone, Serialize)]
#[serde(rename_all = "camelCase")]
pub struct ValidationError {
    /// Field that failed validation
    pub field: String,
    /// Human-readable error message
    pub message: String,
    /// Step name for grouping
    pub step: String,
    /// Path to navigate for fixing
    pub fix_path: String,
}

/// Validation result.
#[derive(Debug, Clone, Serialize)]
#[serde(rename_all = "camelCase")]
pub struct ValidationResult {
    pub success: bool,
    pub errors: Vec<ValidationError>,
    pub config_path: Option<String>,
}

impl UserConfig {
    /// Validate the configuration.
    #[must_use]
    pub fn validate(&self) -> ValidationResult {
        let mut errors = Vec::new();

        // Profile validation
        if self.profile.display_name.trim().is_empty() {
            errors.push(ValidationError {
                field: "displayName".to_string(),
                message: "Display name is required".to_string(),
                step: "profile".to_string(),
                fix_path: "/setup/profile".to_string(),
            });
        }

        if self.profile.jira_email.trim().is_empty() {
            errors.push(ValidationError {
                field: "jiraEmail".to_string(),
                message: "Jira email is required".to_string(),
                step: "profile".to_string(),
                fix_path: "/setup/profile".to_string(),
            });
        }

        if self.profile.ticket_states.is_empty() {
            errors.push(ValidationError {
                field: "ticketStates".to_string(),
                message: "At least one ticket state is required".to_string(),
                step: "profile".to_string(),
                fix_path: "/setup/profile".to_string(),
            });
        }

        // Jira validation
        if self.integrations.jira.instance_url.trim().is_empty() {
            errors.push(ValidationError {
                field: "jira.instanceUrl".to_string(),
                message: "Jira instance URL is required".to_string(),
                step: "jira".to_string(),
                fix_path: "/setup/jira".to_string(),
            });
        }

        // Validate based on auth type using map_or (idiomatic Rust)
        match self.integrations.jira.auth_type {
            JiraAuthType::ApiToken => {
                if self
                    .integrations
                    .jira
                    .email_encrypted
                    .as_ref()
                    .map_or(true, std::string::String::is_empty)
                {
                    errors.push(ValidationError {
                        field: "jira.email".to_string(),
                        message: "Jira email is required for API Token auth".to_string(),
                        step: "jira".to_string(),
                        fix_path: "/setup/jira".to_string(),
                    });
                }
                if self
                    .integrations
                    .jira
                    .api_token_encrypted
                    .as_ref()
                    .map_or(true, std::string::String::is_empty)
                {
                    errors.push(ValidationError {
                        field: "jira.apiToken".to_string(),
                        message: "Jira API Token is required".to_string(),
                        step: "jira".to_string(),
                        fix_path: "/setup/jira".to_string(),
                    });
                }
            }
            JiraAuthType::OAuth => {
                if self
                    .integrations
                    .jira
                    .client_id_encrypted
                    .as_ref()
                    .map_or(true, std::string::String::is_empty)
                {
                    errors.push(ValidationError {
                        field: "jira.clientId".to_string(),
                        message: "Jira OAuth Client ID is required".to_string(),
                        step: "jira".to_string(),
                        fix_path: "/setup/jira".to_string(),
                    });
                }
                if self
                    .integrations
                    .jira
                    .client_secret_encrypted
                    .as_ref()
                    .map_or(true, std::string::String::is_empty)
                {
                    errors.push(ValidationError {
                        field: "jira.clientSecret".to_string(),
                        message: "Jira OAuth Client Secret is required".to_string(),
                        step: "jira".to_string(),
                        fix_path: "/setup/jira".to_string(),
                    });
                }
            }
        }

        ValidationResult {
            success: errors.is_empty(),
            errors,
            config_path: None,
        }
    }

    /// Validate that encrypted secrets can be decrypted.
    #[must_use]
    pub fn validate_decryption(&self, encryptor: &Encryptor) -> ValidationResult {
        let mut errors = Vec::new();

        // Try to decrypt Jira credentials based on auth type
        match self.integrations.jira.auth_type {
            JiraAuthType::ApiToken => {
                if let Some(ref email) = self.integrations.jira.email_encrypted {
                    if encryptor.decrypt(email).is_err() {
                        errors.push(ValidationError {
                            field: "jira.email".to_string(),
                            message: "Failed to decrypt Jira email".to_string(),
                            step: "jira".to_string(),
                            fix_path: "/setup/jira".to_string(),
                        });
                    }
                }
                if let Some(ref token) = self.integrations.jira.api_token_encrypted {
                    if encryptor.decrypt(token).is_err() {
                        errors.push(ValidationError {
                            field: "jira.apiToken".to_string(),
                            message: "Failed to decrypt Jira API Token".to_string(),
                            step: "jira".to_string(),
                            fix_path: "/setup/jira".to_string(),
                        });
                    }
                }
            }
            JiraAuthType::OAuth => {
                if let Some(ref client_id) = self.integrations.jira.client_id_encrypted {
                    if encryptor.decrypt(client_id).is_err() {
                        errors.push(ValidationError {
                            field: "jira.clientId".to_string(),
                            message: "Failed to decrypt Jira Client ID".to_string(),
                            step: "jira".to_string(),
                            fix_path: "/setup/jira".to_string(),
                        });
                    }
                }
                if let Some(ref client_secret) = self.integrations.jira.client_secret_encrypted {
                    if encryptor.decrypt(client_secret).is_err() {
                        errors.push(ValidationError {
                            field: "jira.clientSecret".to_string(),
                            message: "Failed to decrypt Jira Client Secret".to_string(),
                            step: "jira".to_string(),
                            fix_path: "/setup/jira".to_string(),
                        });
                    }
                }
            }
        }

        // Try to decrypt optional integrations
        if let Some(ref postman) = self.integrations.postman {
            if encryptor.decrypt(&postman.api_key_encrypted).is_err() {
                errors.push(ValidationError {
                    field: "postman.apiKey".to_string(),
                    message: "Failed to decrypt Postman API key".to_string(),
                    step: "postman".to_string(),
                    fix_path: "/setup/postman".to_string(),
                });
            }
        }

        if let Some(ref testmo) = self.integrations.testmo {
            if encryptor.decrypt(&testmo.api_key_encrypted).is_err() {
                errors.push(ValidationError {
                    field: "testmo.apiKey".to_string(),
                    message: "Failed to decrypt Testmo API key".to_string(),
                    step: "testmo".to_string(),
                    fix_path: "/setup/testmo".to_string(),
                });
            }
        }

        ValidationResult {
            success: errors.is_empty(),
            errors,
            config_path: None,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn test_encryptor() -> Encryptor {
        Encryptor::from_hex_key("0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef")
            .unwrap()
    }

    #[test]
    fn test_user_config_from_wizard_input_api_token() {
        let encryptor = test_encryptor();

        let input = SetupWizardInput {
            profile: ProfileInput {
                display_name: "Test User".to_string(),
                jira_email: "test@example.com".to_string(),
                ticket_states: vec!["Ready for QA".to_string()],
            },
            jira: JiraInput {
                instance_url: "https://test.atlassian.net".to_string(),
                auth: JiraAuthInput::ApiToken {
                    email: "test@example.com".to_string(),
                    api_token: SecretString::from("token-123".to_string()),
                },
            },
            postman: None,
            testmo: None,
            splunk: None,
        };

        let config = UserConfig::from_wizard_input(input, &encryptor).unwrap();

        assert_eq!(config.version, "1.0");
        assert_eq!(config.profile.display_name, "Test User");
        assert_eq!(
            config.integrations.jira.instance_url,
            "https://test.atlassian.net"
        );
        assert!(matches!(
            config.integrations.jira.auth_type,
            JiraAuthType::ApiToken
        ));
        assert!(config.integrations.jira.email_encrypted.is_some());
        assert!(config.integrations.jira.api_token_encrypted.is_some());
    }

    #[test]
    fn test_user_config_from_wizard_input_oauth() {
        let encryptor = test_encryptor();

        let input = SetupWizardInput {
            profile: ProfileInput {
                display_name: "Test User".to_string(),
                jira_email: "test@example.com".to_string(),
                ticket_states: vec!["Ready for QA".to_string()],
            },
            jira: JiraInput {
                instance_url: "https://test.atlassian.net".to_string(),
                auth: JiraAuthInput::OAuth {
                    client_id: "client-123".to_string(),
                    client_secret: SecretString::from("secret-456".to_string()),
                },
            },
            postman: None,
            testmo: None,
            splunk: None,
        };

        let config = UserConfig::from_wizard_input(input, &encryptor).unwrap();

        assert_eq!(config.version, "1.0");
        assert_eq!(config.profile.display_name, "Test User");
        assert_eq!(
            config.integrations.jira.instance_url,
            "https://test.atlassian.net"
        );
        assert!(matches!(
            config.integrations.jira.auth_type,
            JiraAuthType::OAuth
        ));
        assert!(config.integrations.jira.client_id_encrypted.is_some());
        assert!(config.integrations.jira.client_secret_encrypted.is_some());
    }

    #[test]
    fn test_user_config_validation() {
        let config = UserConfig {
            version: "1.0".to_string(),
            profile: UserProfile {
                display_name: "".to_string(), // Invalid
                jira_email: "test@example.com".to_string(),
                ticket_states: vec![], // Invalid
            },
            integrations: IntegrationsConfig {
                jira: JiraConfig {
                    instance_url: "https://test.atlassian.net".to_string(),
                    auth_type: JiraAuthType::ApiToken,
                    email_encrypted: Some("encrypted".to_string()),
                    api_token_encrypted: Some("encrypted".to_string()),
                    client_id_encrypted: None,
                    client_secret_encrypted: None,
                },
                postman: None,
                testmo: None,
            },
            splunk: None,
        };

        let result = config.validate();
        assert!(!result.success);
        assert_eq!(result.errors.len(), 2);
    }

    #[test]
    fn test_user_config_to_yaml() {
        let config = UserConfig {
            version: "1.0".to_string(),
            profile: UserProfile {
                display_name: "Test User".to_string(),
                jira_email: "test@example.com".to_string(),
                ticket_states: vec!["Ready for QA".to_string()],
            },
            integrations: IntegrationsConfig {
                jira: JiraConfig {
                    instance_url: "https://test.atlassian.net".to_string(),
                    auth_type: JiraAuthType::OAuth,
                    email_encrypted: None,
                    api_token_encrypted: None,
                    client_id_encrypted: Some("encrypted-id".to_string()),
                    client_secret_encrypted: Some("encrypted-secret".to_string()),
                },
                postman: None,
                testmo: None,
            },
            splunk: None,
        };

        let yaml = config.to_yaml().unwrap();
        assert!(yaml.contains("version: '1.0'"));
        assert!(yaml.contains("displayName: Test User"));
        assert!(yaml.contains("instanceUrl: https://test.atlassian.net"));
    }
}
